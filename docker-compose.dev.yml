services:
  traefik:
    image: traefik:v3.0
    command:
      - --api.dashboard=true
      - --api.insecure=true
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --accesslog=true
      - --entryPoints.websecure.transport.respondingTimeouts.readTimeout=10s
    ports:
      - "8001:80"      # Development on different port
      # - "443:443"
      - "8081:8080"    # Traefik dashboard on different port
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - traefik-dev
    restart: unless-stopped
    depends_on:
      - app
      - web

  app:
    build:
      context: .
      dockerfile: Dockerfile
    env_file:
      - .env.development
    environment:
      - PYTHONUNBUFFERED=1
      - ENVIRONMENT=development
      - PYTHONDONTWRITEBYTECODE=1
    volumes:
      - .:/app
      - /app/__pycache__  # Exclude pycache from volume mount
    command: sh -c "python -m pytest tests/units/test_fill_db_with_data.py::test_fill_database_with_test_data -v && uvicorn src.main:app --host 0.0.0.0 --port 8000 --reload --log-level debug"
    restart: unless-stopped
    depends_on:
      - db
    labels:
      - traefik.enable=true
      - traefik.http.routers.app.rule=PathPrefix("/api") || PathPrefix("/docs") || PathPrefix("/openapi.json")
      - traefik.http.routers.app.entrypoints=web
      - traefik.http.routers.app.priority=10
      - traefik.http.services.app.loadbalancer.server.port=8000
      # Force Traefik to use service name for discovery
      - traefik.docker.network=traefik-dev
    networks:
      - traefik-dev
    ports:
      - "8000:8000"  # Development app on different port
      - "5679:5678"  # Debug port for remote debugging on different port

  db:
    image: postgres:13
    env_file:
      - .env.development
    environment:
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=postgres  # Use default postgres database for initial connection
      - DB_NAME=${DB_NAME}    # Pass DB_NAME to init script
    ports:
      - "5433:5432"  # Development database on different port
    volumes:
      - postgres_data_dev:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d  # For development database initialization scripts
    networks:
      - traefik-dev
    restart: unless-stopped

  web:
    build:
      context: ./frontend
    env_file:
      - .env.development
    command: pnpm dev
    ports:
      - "3001:3000"  # Development frontend on different port
    environment:
      - NODE_ENV=development
      - FAST_REFRESH=true
      - WATCHPACK_POLLING=true
    volumes:
      - ./frontend:/app
      - /app/node_modules  # Exclude node_modules from volume mount
      - /app/.next  # Exclude .next from volume mount
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:3000', (res) => process.exit(res.statusCode === 200 || res.statusCode === 404 ? 0 : 1)).on('error', () => process.exit(1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    labels:
      - traefik.enable=true
      - traefik.http.routers.web.rule=PathPrefix("/") && !PathPrefix("/api")
      - traefik.http.routers.web.entrypoints=web
      - traefik.http.routers.web.priority=1
      - traefik.http.services.web.loadbalancer.server.port=3000
      # Force Traefik to use service name for discovery
      - traefik.docker.network=traefik-dev
    networks:
      - traefik-dev
    restart: unless-stopped
    depends_on:
      - app


volumes:
  postgres_data_dev:
  redis_data_dev:
  pgadmin_data_dev:
  node_modules_cache_dev:
  nextjs_cache_dev:

networks:
  traefik-dev:
    driver: bridge
